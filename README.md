# Taxi Management System

Система управления такси с использованием процессов, межпроцессного взаимодействия (IPC) и таймеров.

## Функциональность

Система состоит из двух основных компонентов:

### CLI (Command Line Interface)

- **Опорный пункт** - основное приложение управления
- **Команды:**
  - `create_driver` - создание нового процесса-водителя
  - `send_task <pid> <task_timer>` - назначение задачи водителю
  - `get_status <pid>` - получение статуса конкретного водителя
  - `get_drivers` - отображение статусов всех водителей
  - `exit` - завершение работы системы

### Driver Process

- **Процесс-водитель** - независимый процесс, выполняющий задачи
- **Состояния:**
  - `Available` - свободен, готов к выполнению задач
  - `Busy <timer>` - занят выполнением задачи, показывает оставшееся время

## Особенности реализации

### Структура проекта

```
taxi_system/
├── build/ 
├── include/
│   ├── cli.h
│   ├── driver.h
│   └── common.h
├── src/
│   ├── cli/
│   │   ├── main.c
│   │   └── dcli.c
│   ├── driver/
│   │   ├── main.c
│   │   └── driver.c
│   └── common/
│       └── common.c
└── Makefile
```

### Архитектура

```
CLI (родительский процесс)
│
├── Driver Process 1 (дочерний процесс)
│ ├── FIFO: /tmp/taxi_driver_<PID1> (команды)
│ └── FIFO: /tmp/taxi_driver_response_<PID1> (ответы)
├── Driver Process 2
└── Driver Process N
```

### Межпроцессное взаимодействие (IPC)

- **Два именованных канала (FIFO)** на каждого водителя для двусторонней коммуникации
- **Командный FIFO:** `/tmp/taxi_driver_<PID>` - для отправки команд от CLI
- **Ответный FIFO:** `/tmp/taxi_driver_response_<PID>` - для получения ответов от драйвера

**Структуры данных:**
```c
// Команда от CLI к драйверу
typedef struct {
    CommandType type;    // CMD_SEND_TASK, CMD_GET_STATUS, CMD_EXIT
    int task_timer;      // время выполнения задачи
} Command;

// Ответ от драйвера к CLI  
typedef struct {
    char response[BUFFER_SIZE];  // "Available", "Busy 15", "Task received: 30 seconds"
} Response;
```

### Управление таймерами

#### В Driver Process:
- Использование poll() с таймаутом для неблокирующего ожидания команд
- Автономное отслеживание времени выполнения задачи с помощью time()
- Автоматический переход в статус Available по истечении времени задачи
- При повторной задаче во время выполнения возвращает `Busy <remaining_time>`

### Особенности реализации
- Автономность драйверов - каждый драйвер полностью независим и сам управляет своим состоянием
- Двусторонняя асинхронная коммуникация - через раздельные FIFO для команд и ответов
- Эффективные таймеры - без busy-wait, использование системных вызовов времени
- Обработка конкурентных запросов - корректная обработка повторных задач к занятому драйверу

### Многозадачность

- Параллельная работа множества водителей
- Неблокирующие операции ввода-вывода
- Эффективное использование ресурсов без активного ожидания

## Требования к системе

- Linux/UNIX-подобная операционная система
- Компилятор GCC
- Стандартные библиотеки C

## Сборка и запуск

``` bash
# Компиляция
make

# Переход в папку со сборками
cd build

# Запуск системы
./cli

# В CLI выполнить команды:
create_driver
send_task 12345 30  # Назначить задачу на 30 секунд
get_status 12345
get_drivers
exit
```

## Безопасность и надежность

- Обработка ошибок системных вызовов
- Защита от частичного чтения/записи в FIFO
- Корректное освобождение ресурсов при завершении
- Проверка существования FIFO перед созданием

## Ограничения

- Размер буфера команд: 1024 байт

Система демонстрирует эффективное использование процессов, IPC и таймеров в UNIX-подобных системах для построения распределенных приложений.
